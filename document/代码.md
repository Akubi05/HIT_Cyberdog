# 1 导入

```
from pyzbar import pyzbar

from NodeBase import SteroCameraNode, DepthNode, QRCodeDetector ,YellowLightDetector
from CtrlBase import Robot_Ctrl,State
from color_config import *
```

pyzbar是检测二维码的包,自行pip install

NodeBase.py,CtrlBase.py,color_config.py自定义文件

# 2 函数和类
```

class Color(Enum):

class Direction(Enum):

def findAllFile(base):

def signal_handler(sig, frame):


class adjustment(Enum):



# 在图像的下半部分检测 紫色区域，如果检测到足够大的紫色轮廓，就返回 True
class PurpleDetector():


# 绿色箭头
class ArrowDetector:

# 对齐
class duiqi():

# 根据输入的航向角误差 yaw（单位：弧度），发送一条原地转向控制指令给机器人，使其转动一定时间，从而完成姿态校正。
def jiaozheng_bianxian(yaw): #弧度

#new!!!!!!!!!!
def go_short_bianxian(vel, duration):  # 前进

def duiqi_control(Right):

duiqi_node = duiqi()

class s_curve_processor():

# 鱼眼相机 仅s弯用,二维码等使用的普通相机
class SteroCameraNode(Node):

#rgb for s_cur 识别二维码等
class RGBCameraNode(Node):

#语音节点
class SpeechProcessor(Node):

#视觉节点
class VisionNode(Node):
- 狗的整个赛道逻辑,识别全部在这里
- 说几个重点
- self.real_debug_mode = False debug 模式 ,仿真阶段需要imshow,但是实机没有图形界面,需要关闭
- self.debug_mode = False debug 模式 ,仿真阶段需要imshow,但是实机没有图形界面,需要关闭 (由于版本原因,和上面重复了,但是别改)
- self._detected_flags 判断变量初始值 , 每加一个状态需要在里面增加
- def process_image(self, img_type, cv_image): 每加一个状态需要在里面增加
- _detect_0等检测函数,具体如何识别逻辑,只识别,识别到则设置变量为true
- def _0_detected(self):     @property  方便返回值


def loadtoml(file):

def main_detection_loop(depth_node, ctrl, msg, trigger_distance, detection_type):

def standup():  # 站立

def stone_road(duration):  # 石板路

def limit(ctrl, msg, duration=9):
    """限高杆动作"""

def upslope(step = 14):   上坡

def downslope():  下坡

def stand(): 不知道是啥

def new_move(left=None,acc=None):

def move(flag,adjust):

def go_center(left):

def process(rotate_speed):


purple_detector = PurpleDetector()
arrow_detector = ArrowDetector()
processor = s_curve_processor()
order = 1

#flag for left or right 0 for left 1 for right
def detecte(flag,index,flag_change):   


def run_cur():  # 走s弯

def jiaozheng1():

def jiaozheng2():

def xuanzhuan(direction):

def jiaozheng(yaw): #弧度

BIA = 0.27576 - 0.164
detector = YellowLightDetector()

def yellowlight(vel=0.2, step=0.01, duration=2000): 黄灯检测

def walk(duration = 5, dir = 0.00):   正常走

def down(): 不知道是啥

def spin_executor(): 不知道是啥


yaw = 0.0
arrow_direction = Direction.UNKNOWN
arrow_lock = Lock()  # 保证线程安全
arrow = None
state_id = 0
now_state = 0
QR1 = ''
QR2 = ''
QR1_cnt = 0
QR2_cnt = 0
who = 10
Ctrl = Robot_Ctrl()
Ctrl.run()
msg = robot_control_cmd_lcmt()

rclpy.init()

detector = YellowLightDetector()

vision_node = VisionNode()
rgb_camera = SteroCameraNode("rgb_camera")
real_rgb_camera = RGBCameraNode("real_rgb_camera")
depth_node = DepthNode('slope')
speech_node = SpeechProcessor()
executor = MultiThreadedExecutor()
executor.add_node(rgb_camera)
executor.add_node(vision_node)
executor.add_node(depth_node)
executor.add_node(real_rgb_camera)
executor.add_node(speech_node)
# 添加节点到执行器

spin_thread = Thread(target=spin_executor)
spin_thread.start()
```

# 3 主函数main

```
    global state_id 状态
    global now_state 不知道是啥
    global QR1 二维码
    global QR2 二维码
    global arrow 箭头是啥
    global order 不知道
    global msg 
    global limittime
    global who
    QR1 = 'A-2' # 二维码1
    QR2 = 'B-2' # 二维码2

    arrow = Direction.Left

    # 状态机初始化
    state_id = 1
    depth_node.set_node_running(False)
    state_entry_time = time.time()
    last_cmd_time = time.time()
    cmd_interval = 0.1  # 命令发送间隔（秒）

    while循环是主运动逻辑:

    elif state_id == x:
        if current_time - last_cmd_time > cmd_interval:
        此状态默认动作;

        if vision_node._x_detected (flag真):
            检测到因该做的动作;
            转下一步;
```

